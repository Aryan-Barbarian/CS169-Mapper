var Mapper = (function () {
// nothing here can be tested, keep it simple


	var allPoints;
	var currColor;
	var apiUrl;
	var varList = null
	var datasetList = null
	var datasets = null

	var geoList = ["USA", "Alabama", 
									"Alaska", 
									"Arizona",
									"Arkansas", 
									"California", 
									"Colorado", 
									"Connecticut", 
									"Delaware",
									"Florida", 
									"Georgia", 
									"Hawaii", 
									"Idaho", 
									"Illinois", 
									"Indiana", 
									"Iowa", 
									"Kansas", 
									"Kentucky", 
									"Louisiana", 
									"Maine", 
									"Maryland", 
									"Massachusetts", 
									"Michigan", 
									"Minnesota", 
									"Mississippi", 
									"Missouri", 
									"Montana",
                  "Nebraska", 
									"Nevada", 
									"New Hampshire", 
									"New Jersey", 
									"New Mexico", 
									"New York", 
									"North Carolina", 
									"North Dakota", 
									"Ohio", 
									"Oklahoma", 
									"Oregon", 
									"Pennsylvania", 
                  "Rhode Island", 
									"South Carolina", 
									"South Dakota", 
									"Tennessee", 
									"Texas", 
									"Utah", 
									"Vermont", 
									"Virginia", 
									"Washington", 
									"West Virginia", 
									"Wisconsin", 
									"Wyoming"]

	var mapId = null
	var datasetId = 1 //TODO: Make sure this is kept safe!
	var userId = 1
	var displayval; //string
	var filterval; //string
	var geoval; //string

	//methods dealing with front end

  var makeSlider = function() {
    var displayPoints = (allPoints.points).map(function(point) { return point.filter_val })
    var minVal = Math.max(0, Math.floor(Math.min.apply(null, displayPoints)))
    var maxVal = Math.floor(Math.max.apply(null, displayPoints))

    console.log("minVal: "+minVal+", maxVal: "+maxVal);

    $( "#slider-range" ).slider({
        range: true,
        min: minVal,
        max: maxVal,
        values: [ minVal, maxVal ],
        slide: function( event, ui ) {
          $( "#range-display" ).val(ui.values[ 0 ] + " - " + ui.values[ 1 ] );
        }
      });
      $( "#range-display" ).val($( "#slider-range" ).slider( "values", 0 ) +
        " - " + $( "#slider-range" ).slider( "values", 1 ) );

      $('#select-range').on("click", function() {
        console.log("clicked");
      });
      
      $('#select-range').on("click", function() {
        var filtermin = $("#slider-range").slider("values",0);
        var filtermax = $( "#slider-range" ).slider( "values", 1);

        console.log("filtermin: "+filtermin+", filtermax: "+filtermax);

        var dataPoints = MapperBack.filterPoints(allPoints, filtermin, filtermax);
        drawMap(dataPoints);
      });
    }


    var loadDatasets = function() {
    	// Loads all legal datasets
    	var datasetsUrl = apiUrl + "/datasets"
    	
    	var success = function(data) {
    		console.log("loaded datasets: " + datasets)
    		console.log(data)
    		datasets = new Array()
    		datasetList = new Array()
    		for (var i = data.length - 1; i >= 0; i--) {
    			datasets.push(data[i])
    			datasetList.push(data[i].name)
    		}

    		// $("#iddataset").on('input propertychange paste autocompleteselect', function() {
    		$("#iddataset").on('change', function() {
    			console.log("Dataset Change Detected")
    			datasetName = this.value
    			dataset = findDatasetByName($('#iddataset').val())
    			datasetId = dataset.id
    			console.log(datasetId)
    			loadColumnsAsync(dataset.columns)
	    	});
    	}

    	makeGetRequest(datasetsUrl, null, success)


    }

    var loadColumns = function(datasetId) {
    	// Loads all legal columns
    	var datasetUrl = apiUrl + "/datasets/" + datasetId

    	var success = function(dataset) {
    		var columns = dataset.columns
    		loadColumnsAsync(columns)
    	}


    	makeGetRequest(datasetUrl, null, success)
    }


    var loadColumnsAsync = function(columns) {
    	$("#idfilteringvar").html("")
		$("#idvar").html("")
		varList = new Array()

		for (var i = columns.length - 1; i >= 0; i--) {
			var column = columns[i]
			if (column.column_type === "VARIABLE") {
				varList.push(column.name)
			}
		};

		startAutocomplete()
    }



	var startAutocomplete = function() {
		$("#idvar").autocomplete({
			source: varList,
			minLength: 0,
			scroll: true,
      autoFocus: true
		}).focus(function() {
				$(this).autocomplete("search", "");
		});

		$("#iddataset").autocomplete({
			source: datasetList,
			minLength: 0,
			scroll: true,
			
      autoFocus: true
		}).focus(function() {
				$(this).autocomplete("search", "");
		});

		$("#idfilteringvar").autocomplete({
			source: varList,
			minLength: 0,
			scroll: true
		}).focus(function() {
				$(this).autocomplete("search", "");
		});

		$("#idgeo").autocomplete({
			source: geoList,
			minLength: 0,
			scroll: true
		}).focus(function() {
				$(this).autocomplete("search", "");
		});
	}

	var submitClickHandler = function() {
			$( "body" ).on( "click", "#idsubmit", function() {
				//set values
				apiUrl = MapperBack.getapiUrl();
				displayval = $("#idvar").val();
				filterval = $("#idfilteringvar").val();
				geoval = $("#idgeo").val();
				datasetId_possible = findDatasetByName($('#iddataset').val())
				if (datasetId_possible) {
					datasetId = datasetId_possible.id
				}


				//set URL
				// apiUrl += '&display_val=' + displayval.toUpperCase().replace(' ', '_');
				// if (filterval) '&filter_val=' + filterval.toUpperCase().replace(' ', '_');

				//hide stuff
				$("div#canvas").html('');
				$("#legend").html('')
				$(".secondContainer").removeClass('hidden');
				$(".firstContainer").addClass('hidden');
				start();

		});
	}

	var submitHomeClickHandler = function() {
			$( "body" ).on( "click", "#idsubmit", function() {
				//set values
				apiUrl = MapperBack.getapiUrl();
				displayval = $("#idvar").val();
				filterval = $("#idfilteringvar").val();
				geoval = $("#idgeo").val();

				params = gatherMapVariables()
				saveUrl = apiUrl + "maps/"

				$.redirect(saveUrl, params, "POST")

		});
	}

	var makeGetRequest = function(url, params, onSuccess, onFailure) {
		makeAjaxRequest(url, "GET", params, onSuccess, onFailure)
	};

	var makePutRequest = function(url, params, onSuccess, onFailure) {
		makeAjaxRequest(url, "PUT", params, onSuccess, onFailure)
	};

	var makePostRequest = function(url, params, onSuccess, onFailure) {
		makeAjaxRequest(url, "POST", params, onSuccess, onFailure)
	};

	/**
	* HTTP request 
	* @param  {string}   url       URL path, e.g. "/api/smiles"
	* @param  {function} onSuccess   callback method to execute upon request success (200 status)
	* @param  {function} onFailure   callback method to execute upon request failure (non-200 status)
	* @return {None}
	*/
	var makeAjaxRequest = function(url, http_method, params, onSuccess, onFailure) {
		console.log ("making a request to : " + url)
		$.ajax({
			type: http_method,
			url: url,
			data: params,
			dataType: "json",
			success: onSuccess,
			error: onFailure,
			xhrFields: {
				withCredentials: true
			},
			headers: {
			  'X-CSRF-Token': $('meta[name="csrf-token"]').attr('content')
			}
		});
	};

	//Methods dealing with the map
	//adds title to our graph
	var addTitle = function(svg)
	{
		svg.append("text")
				.attr("x", 100)             
				.attr("y", 50)
				.attr("text-anchor", "middle")  
				.style("font-size", "16px") 
				.style("text-decoration", "underline")  
				// .text("Make me a pretty title");
	}

	//add the legend to the plot
	var addLegend = function (svg, data_quantize) 
	{
    $("#legend").html("");
		//improve this 
		//legend should show each color and what range its for
		// heres an example http://bl.ocks.org/ZJONSSON/3918369
		var data_buckets = data_quantize.range()

		var colors = d3.scale.quantize()
			.range(MapperBack.hexColorDivs(currColor,11));
		var legend = d3.select('#legend')
			.append('ul')
				.attr('class', 'list-inline');
		// debugger
		colors.range().pop();

		var keys = legend.selectAll('li.key').data(colors.range());
		var bucket_i = 0
		keys.enter().append('li')
			.attr('class', 'key')
			.style('border-top-color', String)
			.text(function(d) {
					var bucket = data_buckets[bucket_i]
					bucket_i += 1
					var r = colors.invertExtent(d);
					var curr_range = data_quantize.invertExtent(bucket)
					var first = Math.round(curr_range[0]*100)/100;
					var second = Math.round(curr_range[1]*100)/100;
					return first + " - " + second;
			});
		d3.selectAll('li.key')
			.style('border-top-width', '15px')
			.style('border-top-style', 'solid')
			.style('width', '10%')
			.style('font-size:','.75em');

	}

	var listToColor = function(c)
	{
		return "rgb("+c[0] + "," +c[1] + "," +c[2] + ")";
	}
	//apply the colors to the map
	var applyColors = function(svg, color, divs)
	{
		//debugger;
		var colors = MapperBack.colorDivs(color, divs);
		for (var i = colors.length - 1; i >= 0; i--) 
		{
			//debugger;
			var quart = ".q" + i + "-" + divs;
			var c = colors[i];
			var colorString = "rgb("+c[0] + "," +c[1] + "," +c[2] + ")";
			
			d3.selectAll(quart).style("fill", colorString);

		}
	}
  //color should be in hex format
  var changeColor = function(color)
  {
    //debugger;
    var R = parseInt(color.substring(1,3),16)
    var G = parseInt(color.substring(3,5),16)
    var B = parseInt(color.substring(5,7),16)
    currColor = [R,G,B];
    var colors = MapperBack.hexColorDivs([R,G,B], 10);
    for (var i = colors.length - 1; i >= 0; i--) 
    {
      //debugger;
      var quart = ".q" + i + "-" + 10;
      d3.selectAll(quart).style("fill", colors[i]);

    }


    //Tony make me work pls
    
    var colors = d3.scale.quantize()
      .range(colors);
    // debugger
    //colors.range().pop();


    var keys = d3.selectAll('li.key').data(colors.range());
    keys.enter().append('li')
      .attr('class', 'key')
      .style('border-top-color', String)


    var legendColors = MapperBack.hexColorDivs(currColor,11);
    $('li.key').each(function(i) {
      $(this).css('border-top-color', legendColors[i]);
    });


  }

	 /** createQuantize
		* @param {list} color   base color to start with
		* @param {number} divs  number of divisions
		* @return {quantize} return the quantization var we draw with
		*/
	var createQuantize = function(color, divs, dataPoints)
	{
		var displayPoints = dataPoints.map(function(point) { return point.value })
		var minVal = Math.min.apply(null, displayPoints)
		var maxVal = Math.max.apply(null, displayPoints)
		// var quantize = d3.scale.quantize()
		//     .domain([Math.min.apply(Math,dataPoints.map(function(o) {return o.value;})), 
		//       Math.max.apply(Math,dataPoints.map(function(o) {return o.value;}))])
		//     .range(d3.range(divs).map(function(i) { return "q" + i + "-" + divs; }));

		var quantize = d3.scale.quantize()
				.domain([minVal, maxVal])
				.range(d3.range(divs).map(function(i) { return "q" + i + "-" + divs; }));
 
		return quantize;

	}

	var resize = function (){
		// get width/height with container selector (body also works)
		// or use other method of calculating desired values
		var width = $('#canvas').width(); 

		var height = $('#canvas').height(); 

		// set attrs and 'resume' force 
		//svg = $('#svgMap')
		mapSvg.attr('width', width);
		mapSvg.attr('height', height);
		mapSvg.attr('max-width', width);
		mapSvg.attr('max-height', height);
	}

	// var resize = function() {

	//   width = parseInt(d3.select('#canvas').style('width'))
	//   height = parseInt(d3.select('#canvas').style('height'))
	//   debugger

	//   // update projection
	//   proj.translate([width / 2, height / 2]).scale(width);

	//   // resize the map container
	//   mapSvg.style('width', width + 'px').style('height', height + 'px');

	//   // // resize the map
	//   mapSvg.select('.land').attr('d', path);
	//   mapSvg.selectAll('.state').attr('d', path);
	// }

	
	var proj; //the global variable for projection
	var mapSvg; //the global variable for svg

	/** drawState
		* @param {string} res   draw land, states, or counties
		* @param {string} canvas  id of element ot draw on ('#canvas')
		* @return {svg} return the svg var we draw with
		*/

	var drawUSA = function(res, canvas, quantize, rateById)
	{   
		var background = $(canvas);
		var width = background.width();
		var height = background.height();

		
		var projection = d3.geo.albersUsa()
				.scale(1000)
				.translate([width / 2, height / 2]);
		proj = projection;

		var path = d3.geo.path()
				.projection(projection);

		var svg = d3.select(canvas).append("svg")
				.attr("width", width)
				.attr("height", height);

		mapSvg = svg;

		d3.json("/scripts/us.json", function(error, us) {
			if (error) throw error;
			svg.append("g")
					.attr("class", "states")
				.selectAll("path")
					.data(topojson.feature(us, us.objects.states).features)
				.enter().append("path")
					.attr("class", function(d) { return quantize(rateById.get(d.id)); })
					.attr("d", path)
          .attr("state",function(d) {return d.id})
          .call(d3.helper.tooltip(
            function(d, i){
              return "<b>"+d.properties.name;
            }
            ));
			svg.append("path")
					.datum(topojson.mesh(us, us.objects.states, function(a, b) { return a == b || a !== b; }))
					.attr("class", "states")
					.attr("d", path)

			
			applyColors(null,currColor, 10);
		});

		d3.select(self.frameElement).style("height", height + "px");
		return svg;
	}

	var initialize = function(display_variable, filter_variable, user_id, dataset_id) {
		displayval = display_variable
		filterval = filter_variable
		apiUrl = MapperBack.getapiUrl();
		userId = user_id

		if (dataset_id === null) {
			dataset_id = 1
		}
		datasetId = dataset_id

		loadDatasets()
		loadColumns(dataset_id)
		
	}

	var drawMap = function(dataPoints) {
		$("#canvas").html("");
		var quantize = createQuantize(currColor, 10, dataPoints);

		var width = 870,
		  height = 505;

		var rateById = d3.map();

		for (var i = 0; i < dataPoints.length; i++) {
		  var location = parseInt(dataPoints[i].location) / 1000
		  rateById.set(location, dataPoints[i].value);
		}
		var svg = drawUSA("state", "#canvas", quantize, rateById);

		document.getElementsByTagName('svg')[0].id = 'svgMap';   
		addLegend(svg, quantize);
		addTitle(svg);
		//changeColor('#ff0000');

		d3.select(self.frameElement).style("height", height + "px");
	}

	var start = function() {   
    	currColor = [10,10,100];
		var onSuccess = function(data) {
	     	allPoints = data;
	     	makeSlider();
			var dataPoints = MapperBack.processPoints(data);
	     	drawMap(dataPoints);
		};

		var onFailure = function() {
			console.error('failed to fetch points'); 
		}

		params = gatherPointVariables()
		var pointUrl = apiUrl + "datasets/" + datasetId + "/points"
		makeGetRequest(pointUrl, params,  onSuccess, onFailure);
	};

	var findDatasetById = function(datasetId) {
		for (var i = datasets.length - 1; i >= 0; i--) {
			if (datasets[i].id === datasetId) {
				return datasets[i]
			}
		};
		return null
	}
	var findDatasetByName = function(datasetName) {
		for (var i = datasets.length - 1; i >= 0; i--) {
			if (datasets[i].name === datasetName) {
				return datasets[i]["id"]
			}
		};
		return null
	}

	var gatherPointVariables = function() {
		// TODO: Get these from displayval etc.
		var ans = {}
		ans["display_val"] = displayval
		ans["filter_val"] = filterval
		ans["dataset_id"] = datasetId
		ans["num_points"] = 20000
		return ans
	}

	var gatherMapVariables = function() {
		// TODO: Do me
		var ans = {}
		ans["name"] = "My Fun Map"
		ans["display_variable"] = displayval
		ans["filter_variable"] = filterval
		ans["user_id"] = userId
		ans["dataset_id"] = datasetId
		return ans
	}

	var setMapId = function(newMapId) {
		mapId = newMapId
	}

	var saveMap = function() {
		var onSuccess = function(data) {
			// TODO: Do something?

			console.log(data)
			if (data.id) {
				mapId = data["id"]
			}
		}

		var onFailure = function(data) {
			// TODO: Do something?
			console.error("Failed to save map")
		}

		params = gatherMapVariables()

		var saveUrl
		if (mapId != null) {
			saveUrl = apiUrl + "maps/" + mapId + "/"
			makePutRequest(saveUrl, params, onSuccess, onFailure)
		} else {
			saveUrl = apiUrl + "maps/"
			makePostRequest(saveUrl, params, onSuccess, onFailure)
		}
	}

	d3.select(window).on('resize', resize);


	// PUBLIC METHODS
	// any private methods returned in the hash are accessible via Smile.key_name, e.g. Smile.start()
	
	return {
    makeSlider: makeSlider,
    changeColor: changeColor,
		createQuantize: createQuantize,
		drawUSA: drawUSA,
		start: start,
		initialize: initialize,
		submitClickHandler: submitClickHandler,
		submitHomeClickHandler: submitHomeClickHandler,
		startAutocomplete: startAutocomplete,
		resize: resize,
		saveMap: saveMap,
	};
})();